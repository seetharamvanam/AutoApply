plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0' apply false
    id 'io.spring.dependency-management' version '1.1.4'
}

allprojects {
    group = 'com.autoapply'
    version = '1.0.0-SNAPSHOT'
    
    repositories {
        mavenCentral()
    }
}

subprojects {
    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'
    
    java {
        sourceCompatibility = '17'
        targetCompatibility = '17'
    }
    
    configurations {
        compileOnly {
            extendsFrom annotationProcessor
        }
    }
    
    dependencyManagement {
        imports {
            mavenBom org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES
            mavenBom 'org.springframework.cloud:spring-cloud-dependencies:2023.0.0'
        }
    }
    
    tasks.named('test') {
        useJUnitPlatform()
    }
    
    // Configure bootRun for smooth server lifecycle management
    tasks.named('bootRun') {
        // Enable Spring Boot DevTools-like features
        sourceResources sourceSets.main
        
        // JVM arguments for graceful shutdown and better performance
        jvmArgs = [
            // Graceful shutdown configuration
            '-Dspring.lifecycle.timeout-per-shutdown-phase=30s',
            '-Dserver.shutdown=graceful',
            
            // Memory management
            '-Xms512m',
            '-Xmx1024m',
            
            // GC settings for better performance
            '-XX:+UseG1GC',
            '-XX:MaxGCPauseMillis=200',
            '-XX:+UseStringDeduplication',
            
            // JVM optimizations
            '-XX:+OptimizeStringConcat',
            '-XX:+UseCompressedOops',
            '-XX:+UseCompressedClassPointers',
            
            // Enable JMX for monitoring (optional, can be disabled in production)
            '-Dcom.sun.management.jmxremote',
            '-Dcom.sun.management.jmxremote.port=0',
            '-Dcom.sun.management.jmxremote.authenticate=false',
            '-Dcom.sun.management.jmxremote.ssl=false',
            
            // File encoding
            '-Dfile.encoding=UTF-8',
            '-Duser.timezone=UTC',
            
            // Temp directory (fix Windows permission issue - use user temp instead of C:\Windows\)
            '-Djava.io.tmpdir=' + System.getProperty('user.home') + File.separator + '.autoapply' + File.separator + 'tmp'
        ]
        
        // Standard input handling (prevents blocking)
        standardInput = System.in
        
        // Environment variables
        environment = [
            'SPRING_PROFILES_ACTIVE': project.hasProperty('profile') ? project.property('profile') : 'dev'
        ]
        
        // System properties
        systemProperty 'spring.config.additional-location', 
            project.file('src/main/resources/application.yml').absolutePath
        
        // Fork options for better process management
        doFirst {
            // Ensure temp directory exists
            def tempDir = new File(System.getProperty('user.home'), '.autoapply/tmp')
            tempDir.mkdirs()
            
            println "Starting ${project.name} with graceful shutdown enabled..."
            println "JVM Args: ${jvmArgs.join(' ')}"
        }
        
        // Add shutdown hook for graceful termination
        doLast {
            println "Service ${project.name} is shutting down..."
        }
    }
    
    // Task to check if service is running
    task checkService {
        group = 'application'
        description = 'Check if the service is running'
        doLast {
            def port = project.hasProperty('servicePort') ? project.property('servicePort') : '8080'
            try {
                def connection = new URL("http://localhost:${port}/actuator/health").openConnection()
                connection.setConnectTimeout(2000)
                connection.setReadTimeout(2000)
                connection.connect()
                
                if (connection.responseCode == 200) {
                    println "✅ ${project.name} is running and healthy on port ${port}"
                } else {
                    println "⚠️  ${project.name} responded with status ${connection.responseCode}"
                }
            } catch (Exception e) {
                println "❌ ${project.name} is not responding on port ${port}: ${e.message}"
            }
        }
    }
    
    // Task to wait for service to be ready
    task waitForService {
        group = 'application'
        description = 'Wait for the service to be ready'
        doLast {
            def port = project.hasProperty('servicePort') ? project.property('servicePort') : '8080'
            def maxAttempts = 60
            def attempt = 0
            def ready = false
            
            println "Waiting for ${project.name} to be ready on port ${port}..."
            
            while (attempt < maxAttempts && !ready) {
                try {
                    def connection = new URL("http://localhost:${port}/actuator/health").openConnection()
                    connection.setConnectTimeout(1000)
                    connection.setReadTimeout(1000)
                    connection.connect()
                    
                    if (connection.responseCode == 200) {
                        ready = true
                        println "✅ ${project.name} is ready!"
                    }
                } catch (Exception e) {
                    attempt++
                    Thread.sleep(1000)
                    if (attempt % 5 == 0) {
                        print "."
                    }
                }
            }
            
            if (!ready) {
                throw new RuntimeException("Service ${project.name} did not become ready within ${maxAttempts} seconds")
            }
        }
    }
    
    // Task to gracefully shutdown a running service
    task gracefulShutdown {
        group = 'application'
        description = 'Gracefully shutdown the service via actuator endpoint'
        doLast {
            def port = project.hasProperty('servicePort') ? project.property('servicePort') : '8080'
            try {
                println "Initiating graceful shutdown for ${project.name} on port ${port}..."
                def connection = new URL("http://localhost:${port}/actuator/shutdown").openConnection()
                connection.setRequestMethod('POST')
                connection.setConnectTimeout(2000)
                connection.setReadTimeout(2000)
                connection.connect()
                
                if (connection.responseCode == 200) {
                    println "✅ Graceful shutdown initiated for ${project.name}"
                } else {
                    println "⚠️  Shutdown endpoint returned status ${connection.responseCode}"
                }
            } catch (Exception e) {
                println "❌ Could not reach shutdown endpoint for ${project.name}: ${e.message}"
                println "   Note: Shutdown endpoint requires management.endpoints.web.exposure.include=shutdown"
            }
        }
    }
}

// Root project tasks for managing all services
task checkPorts {
    group = 'application'
    description = 'Check if service ports are available'
    doLast {
        def ports = [
            'gateway-service': 8080,
            'auth-service': 8081,
            'profile-service': 8082,
            'job-parser-service': 8083,
            'resume-tailor-service': 8084,
            'application-tracker-service': 8085
        ]
        
        def conflicts = []
        ports.each { service, port ->
            try {
                def socket = new java.net.ServerSocket(port)
                socket.close()
                println "✅ Port ${port} (${service}) is available"
            } catch (Exception e) {
                conflicts.add("Port ${port} (${service}) is already in use")
                println "❌ Port ${port} (${service}) is already in use"
            }
        }
        
        if (!conflicts.isEmpty()) {
            throw new RuntimeException("Port conflicts detected:\n${conflicts.join('\n')}\n\nPlease stop the services using these ports first.")
        }
    }
}

task startAllServices {
    group = 'application'
    description = 'Start all services in background (use start-services.sh or start-services.ps1 instead)'
    dependsOn checkPorts
    doLast {
        println "⚠️  This task is for checking only. Use start-services.sh or start-services.ps1 to start services."
        println "   Or run: ./gradlew :gateway-service:bootRun :auth-service:bootRun ... (in separate terminals)"
    }
}

